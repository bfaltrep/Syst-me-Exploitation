#include "functions.h"
#include "system.h"
#include "translate.h"
/*
int forkExecIn(OpenFile *executable, AddrSpace *space){
  space = new AddrSpace (executable);
  currentThread->space = space;
  space->InitRegisters ();  // set the initial register values
  space->RestoreState (); // load page table register

  machine->Run ();  // jump to the user progam
  ASSERT (FALSE);   // machine->Run never returns;
  // the address space exits
  // by doing the syscall "exit"
}

int forkExec2(const char * s){
  OpenFile *executable = fileSystem->Open (s);
  AddrSpace *space;

  if (executable == NULL)
  {
    printf ("Unable to open file %s\n", s);
    return 0;
  }
  space = new AddrSpace (executable);

  Thread * res = new Thread("ProcessusTest");

  currentThread->space = space;
  delete executable;    // close file

  space->InitRegisters ();  // set the initial register values
  space->RestoreState (); // load page table register

  machine->Run ();    // jump to the user progam
  ASSERT (FALSE);   // machine->Run never returns;
  return 0;
}
*/

static void StartUserProcessus(void * nointerest){
  currentThread->space->InitRegisters();
  currentThread->space->RestoreState();
  machine->Run ();    // jump to the user progam
  ASSERT (FALSE);   // machine->Run never returns;
}

int forkExec(int s){

  //BOUH pas beau !
  int size = 0;
  int tmp;
  machine->ReadMem(s, 1, &tmp);
  while(tmp != '\0'){
    machine->ReadMem(s+size, 1, &tmp);
    size++;
  }
  char * addr = (char *) malloc(sizeof(char)*size);
  copyStringFromMachine( s, addr, size);

  OpenFile *executable = fileSystem->Open (addr);
  AddrSpace *space;

  if (executable == NULL)
  {
    printf ("Unable to open file : %d and %s\n", s, addr);
    free(addr);
    return 0;
  }
  free(addr);
  space = new AddrSpace (executable);

  Thread * res = new Thread("ProcessusTest");

  currentThread->space = space;
  delete executable;    // close file
/*
  space->InitRegisters();  // set the initial register values
  space->RestoreState (); // load page table register
*/
  res->Start(StartUserProcessus, NULL);
  return 0;
}

int copyStringFromMachine(int from, char *to, unsigned size){
  unsigned int i = 0;
  bool reussite;
  int tmp;
  for ( ; i < size-1; ++i)
  {
    reussite = machine->ReadMem(from+i, 1, &tmp); 

    if (!reussite)
    {
      //on évite d'avoir des chaines de caractères sans EOF en bout, même en cas d'erreur.
      to[i]='\0';
      return i;
    }

    to[i]= tmp;

  	if(to[i] == '\0'){
  		return i;
  	}
  }

  /***** Cas où on ne lit pas d'\0 avant d'arriver jusqu'à size *****/

  to[size-1]='\0';
  return i;
}



int copyStringtoMachine (char * from, int to, unsigned size){

  unsigned int i = 0;
  
  for(; i < size-1;i++){
    machine->WriteMem(to+i, 1,from[i]);
    if(from[i] == '\0' || from[i] == -1){
      break;
    }
  }
  int tmp = '\0';
  machine->WriteMem(to+i, 1,tmp);

  //on sort du for à size-1, or on a écrit size caractère dans ce cas. Donc on incrémente i
  return ++i;
}