#include "syscall.h"
#include "userthread.h"
#include "thread.h"
#include "machine.h"
#include "system.h"
#include "synch.h"
#include "addrspace.h"

// DEBUG('x', "mon debug %d\n", mavar);

int do_ThreadCreate (int f, int arg){
	DEBUG('x', "do_ThreadCreate\n");

	if(currentThread->space->cptSema==NULL){
		currentThread->space->cptSema=new Semaphore("cptSema", 1);
		currentThread->space->cptSema->P();
		currentThread->space->InitNbThread();
		currentThread->space->cptSema->V();
	}
	Thread * res = new Thread("test");
	currentThread->space->cptSema->P();
	int nbThread = currentThread->space->IncrementNbThread();
	DEBUG('x', "\nnbThread :%d\n",nbThread);

	int * function =  (int*)malloc(2*sizeof(int));
	function[0] = f;
	function[1] = arg;
	res->Start(StartUserThread, function);

	if (false)
	{
		return -1;
	}

	return 0;
}


static void StartUserThread(void * _schmurtz){
	int *schmurtz = (int*) _schmurtz;
	DEBUG('x', "\nStartUserThread with function : %p and argument %p\n", *(int*)schmurtz, *(int*)schmurtz+1);
	int i;
 	for (i = 0; i < NumTotalRegs; i++){
		machine->WriteRegister (i, 0);
	}
	machine->WriteRegister (PCReg, schmurtz[0]); 
	machine->WriteRegister (NextPCReg, machine->ReadRegister(PCReg) + 4);

    machine->WriteRegister(4, schmurtz[1]);
	DEBUG('x', "\nRegister 4 : %d\n", machine->ReadRegister(4));

	machine->WriteRegister (StackReg, currentThread->space->AllocateUserStack());
	currentThread->space->cptSema->V();
	free((int *)schmurtz);
    machine->Run();	
    
}

void do_ThreadExit(){
	DEBUG('b', "\nThreadExit\n");
	/*
	Si aucun thread n'est utilisé, on peut tout de même clore le thread principal via cette méthode.
	*/
	if(currentThread->space->cptSema != NULL){
		currentThread->space->cptSema->P();
		int x = currentThread->space->DecrementNbThread();
		currentThread->space->cptSema->V();
		/*
			valgrind nous indique qu'il pourrait y avoir des pertes de mémoires sur 'function'. 
			C'est un risque maitrisé puisqu'une personne qui créer un Thread va nécessairement incrémenter nbThread.
			Ce qui permet que la condition du if distinque le thread principal de ses fils.
		*/
		if(x == 0){
			delete currentThread->space->cptSema;
			interrupt->Halt();
		}
		else {
			currentThread->Finish();
			currentThread->RestoreUserState();
			currentThread->space->RestoreState();
		}
	}else
	{
		interrupt->Halt();
	}
}
